extern crate clap;
extern crate futures;
extern crate grpcio;
extern crate regex;

// Includes the file generated by build.rs
mod proto {
    include!("../proto/mod.rs");
}

use grpcio::Error::RpcFailure;
use grpcio::RpcStatusCode;
use grpcio::{ChannelBuilder, ChannelCredentials, EnvBuilder};
use std::sync::Arc;

use crate::proto::pubsub::{
    AcknowledgeRequest, DeleteSubscriptionRequest, StreamingPullRequest, Subscription,
};
use crate::proto::pubsub_grpc::SubscriberClient;

use crate::proto::example::TestMessage;

use clap::{crate_version, App, Arg};

use std::fmt;

use regex::Regex;

use futures::future::Future;
use futures::sink::Sink;
use futures::stream::Stream;
use futures::{Async, AsyncSink};
use rand::seq::SliceRandom;
use rand::thread_rng;

const GOOGLE_PUBSUB_ENDPOINT: &str = "pubsub.googleapis.com:443";

// constants for generating random named subscriptions
const ADJ: &'static [&'static str] = &[
    "affectionate",
    "agitated",
    "amazing",
    "angry",
    "awesome",
    "beautiful",
    "blissful",
    "bold",
    "boring",
    "brave",
    "busy",
    "charming",
    "clever",
    "cocky",
    "cool",
    "compassionate",
    "competent",
    "condescending",
    "confident",
    "cranky",
    "crazy",
    "dangerous",
    "dazzling",
    "determined",
    "distracted",
    "dreamy",
];

const PER: &'static [&'static str] = &[
    "euler",
    "gagarin",
    "kournikova",
    "kovalevskaya",
    "mendeleev",
    "poklonskaya",
    "pushkin",
    "putin",
    "sharapova",
    "stalin",
    "tereshkova",
    "zhukovsky",
];

// Custom validator for a topic, checks for the correct format of the string.
fn topic_format(v: String) -> Result<(), String> {
    let re = Regex::new(r"^projects/.*/topics/.*$").unwrap();
    if re.is_match(&v) {
        return Ok(());
    }
    Err(String::from(
        "Error: topic must be in the following format: projects/{projectid}/topics/{topic}",
    ))
}

// Custom validator for a topic, checks for the correct format of the string.
fn subscription_format(v: String) -> Result<(), String> {
    let re = Regex::new(r"^projects/.*/subscriptions/.*$").unwrap();
    if re.is_match(&v) {
        return Ok(());
    }
    Err(String::from(
        "Error: subscription must be in the following format: projects/{projectid}/subscriptions/{subname}",
    ))
}

// Generates a subscription name from the topic in the format: projects/{projectid}/subscriptions/{subname}
// projectid is parsed from the topic
// generates a random subscription name from a list.
fn subscription_name_from_topic(v: &str) -> String {
    let re = Regex::new(r"^projects/(.*)/topics/.*$").unwrap();
    let caps = re.captures(v).unwrap();
    let project = caps.get(1).map_or("project", |v| v.as_str());
    fmt::format(format_args!(
        "projects/{}/subscriptions/{}",
        project,
        generate_random_subscription_name()
    ))
}

// Generates a random subscription
// chooses an adjective and a person and combines them like docker.
fn generate_random_subscription_name() -> String {
    let mut rng = thread_rng();
    let adj: &str = ADJ.choose(&mut rng).map(|v| *v).unwrap();
    let per: &str = PER.choose(&mut rng).map(|v| *v).unwrap();
    fmt::format(format_args!("{}_{}", adj, per))
}

fn main() {
    let matches = App::new("Google PubSub Rpc subscriber")
        .version(concat!("v", crate_version!()))
        .about("Example program which connects to Google PubSub Endpoint or emulator given a topic")
        .arg(
            Arg::with_name("topic")
                .short("t")
                .help("The topic on which to publish each message format must be: projects/{projectid}/topics/{topic}")
                .long("topic")
                .env("TOPIC")
                .validator(topic_format)
                .takes_value(true),
        )
        .arg(
            Arg::with_name("subname")
            .short("s")
            .long("subname")
            .help("Sets the subscription name. Format must be: projects/{projectid}/subscriptions/{subname} ")
            .validator(subscription_format)
            .takes_value(true)
        )
        .arg(
            Arg::with_name("local_pubsub")
                .help("Uses the local pubsub emulator instead")
                .long("emulator")
                .env("PUBSUB_EMULATOR_HOST")
                .takes_value(true),
        )
        .get_matches();

    println!("Streaming Client Example");

    let env = Arc::new(EnvBuilder::new().build());

    let emulator = matches.is_present("local_pubsub");

    // Builds the appropriate gRPC channel depending on whether the emulator flag has been set.
    // the emulator does not require credentials
    let chan = if emulator {
        let local_endpoint = matches.value_of("local_pubsub").unwrap();
        ChannelBuilder::new(env).connect(local_endpoint)
    } else {
        let credentials = ChannelCredentials::google_default_credentials().unwrap();
        ChannelBuilder::new(env).secure_connect(GOOGLE_PUBSUB_ENDPOINT, credentials)
    };

    let sc = SubscriberClient::new(chan);

    let topic = matches.value_of("topic").unwrap();

    // Create the subscription request as default as possible
    // Setting no name => a name will be generated for us projects/{project}/subscriptions/{sub}.
    // topic must be set.
    // push_config by default will expect the client to pull messages and require us to ack messages

    let mut subscription_req = Subscription::new();
    if !matches.is_present("subname") {
        subscription_req.set_name(subscription_name_from_topic(topic))
    } else {
        subscription_req.set_name(String::from(matches.value_of("subname").unwrap()))
    };

    subscription_req.set_topic(String::from(topic));
    subscription_req.set_retain_acked_messages(false);

    // Attempt to create a subscription. If a subscription already exists it will catch the error and attempt (once) to recreate it.
    let sub = match sc.create_subscription(&subscription_req) {
        Ok(s) => s,
        Err(RpcFailure(grpcio::RpcStatus {
            status: RpcStatusCode::AlreadyExists,
            details: Some(_),
        })) => {
            let mut delete_sub_req = DeleteSubscriptionRequest::new();
            let sub_name = subscription_req.get_name();

            println!(
                "The subscription: {} already exists .. Attempting to delete it",
                sub_name
            );

            delete_sub_req.set_subscription(sub_name.to_string());

            match sc.delete_subscription(&delete_sub_req) {
                Ok(_) => println!("Successfully deleted: {}", sub_name),
                Err(e) => panic!("Error: Could not delete subscription: {}", e),
            };
            sc.create_subscription(&subscription_req).unwrap()
        }
        Err(e) => panic!("Subscription could not be created. Aborting. {}", e),
    };

    println!("Subscription created successfully: {:?}", sub);

    let (mut sink, responses) = sc.streaming_pull().unwrap();

    // Create a basic streaming pull request. At minimum we must set a subscription name and the stream_ack_deadline_seconds
    let mut spull_req = StreamingPullRequest::new();
    spull_req.set_subscription(String::from(sub.get_name()));
    spull_req.set_stream_ack_deadline_seconds(10);

    //We attempt to send one request to the sink. If we use send or send_all the sink gets consumed and the RPC connection is canceled before we can recieve messages.
    let res = sink.start_send((spull_req, grpcio::WriteFlags::default()));

    match res {
        Ok(AsyncSink::Ready) => println!("Successfully started sending the request"),
        Ok(AsyncSink::NotReady(_)) => println!("Sink not ready"),
        Err(e) => panic!("Error: {}", e),
    };

    // Pulls require us to acknowledge the messages that we have recieved.
    // This is done via an Acknowledge request. We build this once and reuse it as we recieve messages
    let mut ack_req = AcknowledgeRequest::new();
    ack_req.set_subscription(String::from(sub.get_name()));

    let mut acks = protobuf::RepeatedField::new();

    println!("Recieving messages...");

    // After we have sent 1 inital request to the server via the StreamingPullRequest, we should start recieving messages
    // Each item can be a list of 1 or more messages. So we have to iterate through them and keep track of the message id's we have seen  in order to ack them
    let f = responses.for_each(|item| {
        println!("{:?}", item.get_received_messages());
        for msg in item.get_received_messages() {
            acks.push(String::from(msg.get_ack_id()));
            let m = msg.get_message();
            let b = m.get_data();
            let tmsg: TestMessage = protobuf::parse_from_bytes(b).unwrap();
            println!("{:?}", tmsg);
        }
        ack_req.set_ack_ids(acks.clone());
        sc.acknowledge(&ack_req).unwrap();
        Ok(())
    });
    match sink.poll_complete() {
        Ok(Async::Ready(())) => (),
        Ok(Async::NotReady) => (),
        Err(e) => panic!("Could not have completed the send: {}", e),
    };

    // Executes the future and drives it to completion.
    f.wait().unwrap();
}
