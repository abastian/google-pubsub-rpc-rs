extern crate clap;
extern crate grpcio;
extern crate regex;

// Includes the file generated by build.rs
mod proto {
    include!("../proto/mod.rs");
}

use grpcio::{ChannelBuilder, ChannelCredentials, EnvBuilder};
use std::sync::Arc;

use crate::proto::pubsub::{GetTopicRequest, PublishRequest, PubsubMessage, Topic};
use crate::proto::pubsub_grpc::PublisherClient;

use crate::proto::example::TestMessage;

use clap::{crate_version, App, Arg};
use protobuf::Message;

use regex::Regex;

const GOOGLE_PUBSUB_ENDPOINT: &str = "pubsub.googleapis.com:443";

// custom validator for a topic, checks for the correct format of the string.
fn topic_format(v: String) -> Result<(), String> {
    let re = Regex::new(r"^projects/.*/topics/.*$").unwrap();
    if re.is_match(&v) {
        return Ok(());
    }
    Err(String::from(
        "Error: topic must be in the following format: projects/{projectid}/topics/{topic}",
    ))
}
// attempts to create the topic given a name and a publishing client
fn create_topic(topic: &str, p: &PublisherClient) -> Result<Topic, grpcio::Error> {
    let mut topic_req = Topic::new();
    topic_req.set_name(String::from(topic));
    p.create_topic(&topic_req)
}

fn main() {
    let matches = App::new("Google PubSub Rpc publisher")
        .version(concat!("v", crate_version!()))
        .about("Example program which publishes to Google PubSub Endpoint or emulator given a topic")
        .arg(
            Arg::with_name("topic")
                .short("t")
                .help("The topic on which to publish each message format must be: projects/{projectid}/topics/{topic}")
                .long("topic")
                .env("TOPIC")
                .validator(topic_format)
                .takes_value(true),
        )
        .arg(
            Arg::with_name("local_pubsub")
                .help("Uses the local pubsub emulator instead")
                .long("emulator")
                .env("PUBSUB_EMULATOR_HOST")
                .takes_value(true),
        )
        .get_matches();

    let env = Arc::new(EnvBuilder::new().build());

    let emulator = matches.is_present("local_pubsub");

    let c = if emulator {
        let local_endpoint = matches.value_of("local_pubsub").unwrap();
        ChannelBuilder::new(env).connect(local_endpoint)
    } else {
        let credentials = ChannelCredentials::google_default_credentials().unwrap();
        ChannelBuilder::new(env).secure_connect(GOOGLE_PUBSUB_ENDPOINT, credentials)
    };

    let pc = PublisherClient::new(c);

    let topic = matches.value_of("topic").unwrap();

    // if we are using the pubsub emulator we first check to see if the topic exists topic in order to publish messages to it. We attempt to create the topic otherwise
    // if the topic can not be created we abort since we will never be able to publish anything.
    if emulator {
        let mut req = GetTopicRequest::new();
        req.set_topic(String::from(topic));
        let res = pc.get_topic(&req);

        match res {
            Ok(_) => println!("Topic exists.. skipping topic creation."),
            Err(e) => {
                println!(
                    "Topic lookup failed with: {} - Attempting to create the topic",
                    e
                );
                let emulator_host = matches.value_of("local_pubsub").unwrap();
                match create_topic(topic, &pc) {
                            Ok(_) => println!(
                                "Successfully created the topic {} on the pubsub emulator located at: {}",
                                topic, emulator_host
                            ),
                            Err(e) => panic!(
                                "Could not create the topic test on the emulator located at: {} - failed with {}",
                                emulator_host, e
                            ),
                        };
            }
        }
    }

    let mut tmsg = TestMessage::new();
    tmsg.set_id(String::from("test-123"));
    tmsg.set_code(123);
    tmsg.set_field_type(String::from("X"));

    let b = tmsg.write_to_bytes().unwrap();

    let mut r = PublishRequest::new();
    r.set_topic(String::from(topic));

    let mut msg = PubsubMessage::new();
    msg.set_data(b);

    let mut msgs = protobuf::RepeatedField::new();
    msgs.push(msg);

    r.set_messages(msgs);

    println!(
        "This example application will attempt to publish several messages to the following topic: {}",
        topic
    );
    let res = pc.publish(&r);

    match res {
        Ok(s) => println!("Success! {:?}", s),
        Err(e) => println!("Error {:?}", e),
    }
}
